
! 1. To calculate noise channel by channel 
! 2. To calculate the rms of an area  (velocity integrated Tb/flux) 
! 3. To calculate the noise in a velocity range (average Tb/flux). 
! 4. To export the resulted spectrum and noise to ascii files 
! 
! USAGE: 
! RMSSPEC [median] 

! Example: 
! rmsspec
! this is the default version
! 
! rmsspec median
! this also plots the median spectrum calculated from all spectra 

! Done: Consistent check by comparing with base 
! Done: Consider splitting sub-channel when doing integration 
! Done: Pre-existing window setting does not promote setting window now
! Done: Multiple baseline windows  
! Partly Done: implement other output, e.g., Mean, Median, Max, Min, etc  
! TODO: 

! Questions: Sometimes resampled spectra still do not match consistency. 

! CHANGE: change average to stitch -- stitch does not have consistency problem - why? 

! -- pre-request: 
! -- All spectra should be aligned and the loaded index should be consistent.
! -- now it supports to show the median spectrum and to output it in an ascii file 
!  
! written by Zhiyu Zhang
! pmozhang@gmail.com
! last update 19 Dec. 2018 
! last update 30 Oct. 2019 
! last update 05 Nov. 2019 




set velo L
set var bas read
set mod  y t

cl
set unit v 


define char*50 med

if PRO%NARG.ge.1 then
let  med         &1
endif


set box default
stitch
pl

if  SET%LAS%NWIND.ge.1 then 
   if W1[1].ne.0.0 then 
       say "window defined" 
   else
       say "window not defined"
       set win
   endif
else 
   say "window not defined"
   set win
endif

base



! ---  define several different output

define double ry_copy chan_noise chan_mean chan_median  /like ry 
define double chan1 chan2 chans[2] 
define double rmssq[40] ry_copy_sum[40] noisewinsum AreaNoise[40] AreaFlux[40] winchans[40] 
define inte   intchan1 intchan2 


! --- load index 
load /nocheck spec
! --- get the rg% variable 
base /index
pl /index


cl

! ---- channel by channel calculation 
! ---- now we only use rms for the noise calculation 
for i 1 to channels
compute chan_mean[i]   mean   rg[i,]
compute chan_noise[i]  rms    rg[i,]
compute chan_median[i] median rg[i,]
next 
!exam chan_noise
!pause

! --- plot the average spectrum in the upper panel ---  
g\set box 3 25 10 20
!ave
stitch
base
spec 
base 1 /pl

if med.eq."median"
    let ry chan_median 
    base 1 
    spec /pen 1
    pen 1 /wei 2 
    draw t 21 19  "median" 
    pen 0 /wei 2
else 
endif
    draw t 21 18  "mean"  
    draw t 5 19  "Averaged Spectrum" 
draw win 
box n n 
axis YL
set mod x t
greg averaged_spectrum /format 

set mod x t


!  ---------------------------------------------------

! --- plot the noise spectrum in the lower panel   ---
let ry_copy ry
g\set box 3 25 3 10
let ry chan_noise/sqrt(found)
define double meannoise 
compute meannoise mean ry 
set mod y 0  meannoise*1.5
spec

set mod y t
draw t 5 9  "Noise Spectrum" 
draw win
box 
greg noise_spectrum /format 
let ry chan_median 
greg median_spectrum /format 
let ry ry_copy



!  ---------------------------------------------------
!  -- extract flux(area) covered by line-emitting windows
!  ---------------------------------------------------

for i 1 to 40
    if w1[i].ne.0.and.w2[i].ne.0 then 
        set var bas read
        let chans (w1[i]-velocity)/velo_step+reference  (w2[i]-velocity)/velo_step+reference
        
!     --- find out min max of the selected window region

        compute chan1 max chans
        compute chan2 min chans
        
!     --- calculate how many channels that the window region takes 


        let winchans[i] abs((w1[i]-w2[i])/velo_step)

!     --- get the channel numbers of min and max 
       
        let intchan1 nint(chan1) 
        let intchan2 nint(chan2) 
        define double noisewin ry_copy_win /like chan_noise[intchan2:intchan1]
        let noisewin                                     ry[intchan2:intchan1]
        let ry_copy_win                             ry_copy[intchan2:intchan1]
        
!     --- calculate the root mean square  
        let       noisewin       noisewin*noisewin
        compute   noisewinsum    sum  noisewin
!       -- for each window (i), calculate sum for channels within it.  
        let       rmssq[i]      sqrt(noisewinsum/winchans[i])
        
! error propagation: https://math.stackexchange.com/questions/123276/error-propagation-on-weighted-mean 
        let AreaNoise[i] abs(w1[i]-w2[i])*rmssq[i]/sqrt(winchans[i])

        compute          ry_copy_sum[i] sum ry_copy_win

!       say "---"
!       say "window, 1 2: "   'intchan1' 'intchan2'
!       say "sum ry_copy_sum: " 'ry_copy_sum[i]'
!       say "---"
        let              ry_copy_sum[i]     (ry_copy_sum[i]+(intchan1-chan1)*ry_copy[chan1]+(intchan2-chan2)*ry_copy[chan2])

!      say 'intchan1-chan1'
!      say 'intchan2-chan2'
        let AreaFlux[i]  abs(w1[i]-w2[i])*ry_copy_sum[i]/winchans[i]
        
        dele /var noisewin RY_COPY_WIN

    else
    endif 
next

for i 1 to 40
    if rmssq[i].ne.0 then 
        say "-----------------------------------------" 
        say "window" 'i' 
        say "RMS per channel (K):"             'rmssq[i]'
        say "Integrated flux (K km/s):"        'AreaFlux[i]' 
        say "Integrated flux error (K km/s):"  'areanoise[i]'
!       say "channels within window:"  'winchans[i]'
!       say "velocity within window:"  'abs(w1[i]-w2[i])'
!       say "sum of all chans in window"  'ry_copy_sum[i]'
        say "-----------------------------------------" 
     endif 
next

